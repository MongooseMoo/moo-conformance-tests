name: pcre
description: >
  Tests for pcre_match() and pcre_replace() builtins.
  PCRE2 regex support. Guarded by PCRE2_FOUND compile flag.
  pcre_match defaults to case-insensitive and find_all=1.

requires:
  builtins:
    - pcre_match
    - pcre_replace

tests:
  # ===========================================================================
  # pcre_match() - PCRE2 regex matching
  # ===========================================================================

  - name: pcre_match_simple
    description: "Basic pcre_match returns a list with the match value"
    statement: |
      r = pcre_match("foobar", "o+");
      return r[1]["0"]["match"];
    expect:
      value: "oo"

  - name: pcre_match_no_match
    code: 'pcre_match("foobar", "baz")'
    expect:
      value: []

  - name: pcre_match_empty_pattern
    description: "Empty pattern returns E_INVARG"
    code: 'pcre_match("foobar", "")'
    expect:
      error: E_INVARG

  - name: pcre_match_case_insensitive_default
    description: "Default is case-insensitive (PCRE2_CASELESS)"
    statement: |
      r = pcre_match("FooBar", "foo");
      return length(r) > 0;
    expect:
      value: 1

  - name: pcre_match_case_sensitive
    description: "case_matters=1 makes it case-sensitive"
    code: 'pcre_match("FooBar", "foo", 1)'
    expect:
      value: []

  - name: pcre_match_find_all_default
    description: "Default find_all=1 returns all matches"
    statement: |
      r = pcre_match("banana", "a");
      return length(r);
    expect:
      value: 3

  - name: pcre_match_find_first_only
    description: "find_all=0 returns only first match"
    statement: |
      r = pcre_match("banana", "a", 0, 0);
      return length(r);
    expect:
      value: 1

  - name: pcre_match_named_group
    description: "Named capture groups returned as map keys"
    statement: |
      r = pcre_match("2024-01-15", "(?P<year>\\d{4})-(?P<month>\\d{2})-(?P<day>\\d{2})", 0, 0);
      return r[1]["year"]["match"];
    expect:
      value: "2024"

  - name: pcre_match_invalid_pattern
    code: 'pcre_match("foobar", "[unclosed")'
    expect:
      error: E_INVARG

  # ===========================================================================
  # pcre_replace() - PCRE2 regex substitution
  # ===========================================================================

  - name: pcre_replace_basic
    code: 'pcre_replace("foobar", "s/foo/baz/")'
    expect:
      value: "bazbar"

  - name: pcre_replace_global
    description: "/g flag replaces all occurrences"
    code: 'pcre_replace("foofoofoo", "s/foo/bar/g")'
    expect:
      value: "barbarbar"

  - name: pcre_replace_case_insensitive
    description: "/i flag for case-insensitive match"
    code: 'pcre_replace("FooBar", "s/foo/baz/i")'
    expect:
      value: "bazBar"

  - name: pcre_replace_invalid_pattern
    code: 'pcre_replace("foobar", "s/[unclosed/bar/")'
    expect:
      error: E_INVARG

  # ===========================================================================
  # pcre_match() - Return structure tests
  # ===========================================================================

  - name: pcre_match_return_structure
    description: "pcre_match returns list of maps with match and position keys"
    statement: |
      r = pcre_match("hello", "ell", 0, 0);
      return r[1]["0"]["match"];
    expect:
      value: "ell"

  - name: pcre_match_position_values
    description: "Position values are {start, end} with 1-based indexing"
    statement: |
      r = pcre_match("hello", "ell", 0, 0);
      return r[1]["0"]["position"];
    expect:
      value: [2, 4]

  - name: pcre_match_numbered_capture_groups
    description: "Numbered capture groups appear as string keys"
    statement: |
      r = pcre_match("2024-01-15", "([0-9]{4})-([0-9]{2})-([0-9]{2})", 0, 0);
      return {r[1]["1"]["match"], r[1]["2"]["match"], r[1]["3"]["match"]};
    expect:
      value: ["2024", "01", "15"]

  - name: pcre_match_capture_group_positions
    description: "Capture group positions are accurate"
    statement: |
      r = pcre_match("2024-01-15", "([0-9]{4})-([0-9]{2})-([0-9]{2})", 0, 0);
      return r[1]["1"]["position"];
    expect:
      value: [1, 4]

  - name: pcre_match_whole_match_key_zero
    description: "Key '0' contains the whole match"
    statement: |
      r = pcre_match("2024-01-15", "([0-9]{4})-([0-9]{2})-([0-9]{2})", 0, 0);
      return r[1]["0"]["match"];
    expect:
      value: "2024-01-15"

  # ===========================================================================
  # pcre_match() - Multi-match tests
  # ===========================================================================

  - name: pcre_match_find_all_returns_multiple
    description: "find_all=1 returns all matches as list elements"
    statement: |
      r = pcre_match("cat bat hat", "[a-z]at", 0, 1);
      return {r[1]["0"]["match"], r[2]["0"]["match"], r[3]["0"]["match"]};
    expect:
      value: ["cat", "bat", "hat"]

  - name: pcre_match_find_all_count
    description: "find_all returns correct number of matches"
    statement: |
      r = pcre_match("aaa", "a", 0, 1);
      return length(r);
    expect:
      value: 3

  # ===========================================================================
  # pcre_match() - Named groups extended
  # ===========================================================================

  - name: pcre_match_named_group_replaces_numbered
    description: "Named groups replace numbered entries in the map"
    statement: |
      r = pcre_match("hello", "(?P<word>[a-z]+)", 0, 0);
      return r[1]["word"]["match"];
    expect:
      value: "hello"

  - name: pcre_match_named_and_numbered_mixed
    description: "Named and numbered groups coexist in result"
    statement: |
      r = pcre_match("John 42", "(?P<name>[A-Za-z]+) ([0-9]+)", 0, 0);
      return {r[1]["name"]["match"], r[1]["2"]["match"]};
    expect:
      value: ["John", "42"]

  # ===========================================================================
  # pcre_match() - Edge cases
  # ===========================================================================

  - name: pcre_match_special_regex_chars
    description: "Escaped regex special characters match literally"
    statement: |
      r = pcre_match("a.b", "a\\.b", 0, 0);
      return r[1]["0"]["match"];
    expect:
      value: "a.b"

  - name: pcre_match_empty_subject
    description: "Empty subject raises E_INVARG"
    code: 'pcre_match("", "foo")'
    expect:
      error: E_INVARG

  - name: pcre_match_match_at_start
    description: "Match at start of string has position {1, N}"
    statement: |
      r = pcre_match("abc", "ab", 0, 0);
      return r[1]["0"]["position"];
    expect:
      value: [1, 2]

  # ===========================================================================
  # pcre_match() - Error handling
  # ===========================================================================

  - name: pcre_match_type_error_arg1
    description: "Non-string subject raises E_TYPE"
    code: 'pcre_match(42, "foo")'
    expect:
      error: E_TYPE

  - name: pcre_match_type_error_arg2
    description: "Non-string pattern raises E_TYPE"
    code: 'pcre_match("foo", 42)'
    expect:
      error: E_TYPE

  - name: pcre_match_too_many_args
    description: "More than 4 arguments raises E_ARGS"
    code: 'pcre_match("a", "b", 0, 1, 99)'
    expect:
      error: E_ARGS

  - name: pcre_match_too_few_args
    description: "Fewer than 2 arguments raises E_ARGS"
    code: 'pcre_match("a")'
    expect:
      error: E_ARGS

  # ===========================================================================
  # pcre_match() - Case sensitivity detail
  # ===========================================================================

  - name: pcre_match_case_matters_finds_exact
    description: "case_matters=1 still finds exact case matches"
    statement: |
      r = pcre_match("FooBar", "Foo", 1, 0);
      return r[1]["0"]["match"];
    expect:
      value: "Foo"

  # ===========================================================================
  # pcre_match() - Documented example verification
  # ===========================================================================

  - name: pcre_match_documented_example
    description: "Documented example from in-game help"
    statement: |
      r = pcre_match("09/12/1999 other random text 01/21/1952", "([0-9]{2})/([0-9]{2})/([0-9]{4})");
      return r[1]["0"]["match"];
    expect:
      value: "09/12/1999"

  - name: pcre_match_documented_example_second_match
    description: "Second match from documented example"
    statement: |
      r = pcre_match("09/12/1999 other random text 01/21/1952", "([0-9]{2})/([0-9]{2})/([0-9]{4})");
      return r[2]["0"]["match"];
    expect:
      value: "01/21/1952"

  - name: pcre_match_documented_example_positions
    description: "Position values from documented example"
    statement: |
      r = pcre_match("09/12/1999 other random text 01/21/1952", "([0-9]{2})/([0-9]{2})/([0-9]{4})");
      return r[1]["0"]["position"];
    expect:
      value: [1, 10]

  # ===========================================================================
  # pcre_replace() - Backreferences
  # ===========================================================================

  - name: pcre_replace_backreference_numbered
    description: "Numbered backreference $1 in replacement"
    code: 'pcre_replace("John Smith", "s/(\\w+) (\\w+)/$2 $1/")'
    expect:
      value: "Smith John"

  - name: pcre_replace_backreference_whole_match
    description: "$& references the whole match"
    code: 'pcre_replace("hello", "s/hello/[$&]/")'
    expect:
      value: "[hello]"

  - name: pcre_replace_backreference_dollar_zero
    description: "$0 references the whole match"
    code: 'pcre_replace("hello", "s/hello/[$0]/")'
    expect:
      value: "[hello]"

  - name: pcre_replace_multiple_backrefs
    description: "Multiple backreferences in replacement"
    code: 'pcre_replace("2024-01-15", "s!(\\d{4})-(\\d{2})-(\\d{2})!$2/$3/$1!")'
    expect:
      value: "01/15/2024"

  # ===========================================================================
  # pcre_replace() - Alternate delimiter
  # ===========================================================================

  - name: pcre_replace_alternate_delimiter
    description: "Alternate delimiter (!) works for paths with slashes"
    code: 'pcre_replace("/bin/bash", "s!/bin/bash!/bin/fish!")'
    expect:
      value: "/bin/fish"

  # ===========================================================================
  # pcre_replace() - No match
  # ===========================================================================

  - name: pcre_replace_no_match
    description: "No match returns original string unchanged"
    code: 'pcre_replace("hello", "s/xyz/abc/")'
    expect:
      value: "hello"

  # ===========================================================================
  # pcre_replace() - Error handling
  # ===========================================================================

  - name: pcre_replace_type_error_arg1
    description: "Non-string subject raises E_TYPE"
    code: 'pcre_replace(42, "s/a/b/")'
    expect:
      error: E_TYPE

  - name: pcre_replace_type_error_arg2
    description: "Non-string pattern raises E_TYPE"
    code: 'pcre_replace("hello", 42)'
    expect:
      error: E_TYPE

  - name: pcre_replace_too_many_args
    description: "More than 2 arguments raises E_ARGS"
    code: 'pcre_replace("a", "s/a/b/", "extra")'
    expect:
      error: E_ARGS

  - name: pcre_replace_too_few_args
    description: "Fewer than 2 arguments raises E_ARGS"
    code: 'pcre_replace("a")'
    expect:
      error: E_ARGS

  - name: pcre_replace_bad_syntax
    description: "Invalid s/// command syntax raises E_INVARG"
    code: 'pcre_replace("hello", "not a substitution")'
    expect:
      error: E_INVARG

  - name: pcre_replace_missing_delimiter
    description: "Missing closing delimiter raises E_INVARG"
    code: 'pcre_replace("hello", "s/foo/bar")'
    expect:
      error: E_INVARG

  # ===========================================================================
  # pcre_replace() - Documented examples
  # ===========================================================================

  - name: pcre_replace_documented_example_global
    description: "Documented example: global replace"
    code: 'pcre_replace("I like banana pie. Do you like banana pie?", "s/banana/apple/g")'
    expect:
      value: "I like apple pie. Do you like apple pie?"

  - name: pcre_replace_documented_example_excl_delimiter
    description: "Documented example: exclamation mark delimiter"
    code: 'pcre_replace("Unix, wow! /bin/bash is a thing.", "s!/bin/bash!/bin/fish!g")'
    expect:
      value: "Unix, wow! /bin/fish is a thing."

  # ===========================================================================
  # pcre_cache_stats() - Cache statistics
  # ===========================================================================

  - name: pcre_cache_stats_returns_list
    description: "pcre_cache_stats returns a list (wizard only)"
    permission: wizard
    code: 'typeof(pcre_cache_stats()) == typeof({})'
    expect:
      value: 1

  - name: pcre_cache_stats_permission
    description: "Non-wizard calling pcre_cache_stats gets E_PERM"
    permission: programmer
    code: 'pcre_cache_stats()'
    expect:
      error: E_PERM

  - name: pcre_cache_stats_after_match
    description: "After pcre_match, pattern appears in cache stats"
    permission: wizard
    statement: |
      pcre_match("test", "te.t");
      stats = pcre_cache_stats();
      return length(stats) > 0;
    expect:
      value: 1
