name: try_except
description: 'try/except, try/finally, catch expressions (backtick syntax), and raise().
  Tests error handling language features.

  '
tests:
- name: try_except_any
  description: Catch any error with ANY keyword
  statement: "try\n  {}[5];\nexcept e (ANY)\n  return e[1];\nendtry\n"
  expect:
    value: E_RANGE
- name: try_except_no_var
  description: Except clause without variable capture
  statement: "try\n  1 / 0;\nexcept (E_DIV)\n  return \"caught\";\nendtry\n"
  expect:
    value: caught
- name: try_except_multiple_clauses
  description: First matching except clause wins
  statement: "try\n  1 / 0;\nexcept e (E_TYPE)\n  return \"type\";\nexcept e (E_DIV)\n\
    \  return \"div\";\nexcept e (ANY)\n  return \"any\";\nendtry\n"
  expect:
    value: div
- name: try_except_any_catches_all
  description: ANY clause catches all error types
  statement: "try\n  1 / 0;\nexcept e (ANY)\n  return \"any\";\nendtry\n"
  expect:
    value: any
- name: try_except_multi_codes
  description: Single except clause with multiple error codes
  statement: "try\n  1 / 0;\nexcept e (E_TYPE, E_DIV, E_RANGE)\n  return e[1];\nendtry\n"
  expect:
    value: E_DIV
- name: try_except_no_error
  description: Body completes normally, except clause is skipped
  statement: "x = 0;\ntry\n  x = 1;\nexcept (ANY)\n  x = 2;\nendtry\nreturn x;\n"
  expect:
    value: 1
- name: try_except_exception_value_is_list
  description: Captured exception value is a list
  statement: "try\n  1 / 0;\nexcept e (E_DIV)\n  return typeof(e) == LIST;\nendtry\n"
  expect:
    value: 1
- name: try_except_exception_value_has_code
  description: First element of exception value is the error code
  statement: "try\n  1 / 0;\nexcept e (E_DIV)\n  return e[1];\nendtry\n"
  expect:
    value: E_DIV
- name: try_except_exception_value_has_message
  description: Second element of exception value is a string message
  statement: "try\n  1 / 0;\nexcept e (E_DIV)\n  return typeof(e[2]) == STR;\nendtry\n"
  expect:
    value: 1
- name: try_except_unmatched_error_propagates
  description: Error not matching any codes propagates to outer handler
  statement: "try\n  try\n    1 / 0;\n  except (E_TYPE)\n    return \"type\";\n  endtry\n\
    except e (E_DIV)\n  return \"outer\";\nendtry\n"
  expect:
    value: outer
- name: try_except_nested
  description: Nested try/except - inner handler catches first
  statement: "try\n  try\n    {}[5];\n  except (E_RANGE)\n    return \"inner\";\n\
    \  endtry\nexcept (ANY)\n  return \"outer\";\nendtry\n"
  expect:
    value: inner
- name: try_except_return_from_body
  description: Return in try body works normally
  statement: "try\n  return 42;\nexcept (ANY)\n  return 0;\nendtry\n"
  expect:
    value: 42
- name: try_finally_normal
  description: Finally block runs on normal completion
  statement: "x = 0;\ntry\n  x = 1;\nfinally\n  x = x + 10;\nendtry\nreturn x;\n"
  expect:
    value: 11
- name: try_finally_with_error
  description: Finally runs even when error occurs, then error propagates
  statement: "try\n  try\n    x = 1;\n    1 / 0;\n  finally\n    x = x + 10;\n  endtry\n\
    except e (E_DIV)\n  return x;\nendtry\n"
  expect:
    value: 11
- name: try_finally_with_return
  description: 'Return value is captured before finally runs. The finally block executes
    but does not change the return value.

    '
  statement: "x = 0;\ntry\n  x = 1;\n  return x;\nfinally\n  x = x + 10;\nendtry\n"
  expect:
    value: 1
- name: try_finally_nested_in_except
  description: Finally inside try/except - execution order is try, finally, except
  statement: "result = {};\ntry\n  try\n    result = {@result, \"try\"};\n    1 /\
    \ 0;\n  finally\n    result = {@result, \"finally\"};\n  endtry\nexcept (E_DIV)\n\
    \  result = {@result, \"except\"};\nendtry\nreturn result;\n"
  expect:
    value:
    - try
    - finally
    - except
- name: catch_expr_no_error
  description: Expression succeeds, catch returns the expression value
  code: '`1 + 2 ! ANY => 0'''
  expect:
    value: 3
- name: catch_expr_catches_error
  description: Error caught, returns default value
  code: '`1 / 0 ! E_DIV => -1'''
  expect:
    value: -1
- name: catch_expr_any
  description: ANY catches all errors
  code: '`{}[5] ! ANY => "caught"'''
  expect:
    value: caught
- name: catch_expr_specific_code
  description: Only matching error code is caught
  code: '`1 / 0 ! E_DIV => "div"'''
  expect:
    value: div
- name: catch_expr_unmatched_propagates
  description: Unmatched error propagates through catch expression
  statement: "try\n  return `1 / 0 ! E_TYPE => \"type\"';\nexcept e (E_DIV)\n  return\
    \ \"propagated\";\nendtry\n"
  expect:
    value: propagated
- name: catch_expr_no_default
  description: Without => clause, catch returns the error value itself
  code: '`1 / 0 ! E_DIV'''
  expect:
    value: E_DIV
- name: catch_expr_multiple_codes
  description: Multiple error codes in catch expression
  code: '`1 / 0 ! E_TYPE, E_DIV => "caught"'''
  expect:
    value: caught
- name: catch_expr_in_assignment
  description: Catch expression can be used in assignment
  statement: 'x = `1 / 0 ! E_DIV => 42'';

    return x;

    '
  expect:
    value: 42
- name: raise_basic
  description: Raise with error code only
  statement: "try\n  raise(E_INVARG);\nexcept e (E_INVARG)\n  return e[1];\nendtry\n"
  expect:
    value: E_INVARG
- name: raise_with_message
  description: Raise with custom message
  statement: "try\n  raise(E_INVARG, \"custom message\");\nexcept e (E_INVARG)\n \
    \ return e[2];\nendtry\n"
  expect:
    value: custom message
- name: raise_with_value
  description: Raise with custom message and value
  statement: "try\n  raise(E_INVARG, \"msg\", {1, 2, 3});\nexcept e (E_INVARG)\n \
    \ return e[3];\nendtry\n"
  expect:
    value:
    - 1
    - 2
    - 3
- name: raise_caught_by_catch_expr
  description: raise() caught by backtick catch expression
  code: '`raise(E_INVARG) ! E_INVARG => "caught"'''
  expect:
    value: caught
- name: raise_default_message_is_string
  description: Default message for error codes is a string
  statement: "try\n  raise(E_TYPE);\nexcept e (E_TYPE)\n  return typeof(e[2]) == STR;\n\
    endtry\n"
  expect:
    value: 1
- name: raise_propagates_through_finally
  description: raise() error propagates through finally, finally still runs
  statement: "x = 0;\ntry\n  try\n    raise(E_ARGS);\n  finally\n    x = 1;\n  endtry\n\
    except (E_ARGS)\n  return x;\nendtry\n"
  expect:
    value: 1
